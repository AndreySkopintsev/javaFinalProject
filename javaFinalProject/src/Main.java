import userInterface.UserInterface;

import java.util.Scanner;

class Main{
    public static void main(String[] args) {
        //TODO пока разбиение на задачи для группы видится как:
        // София 1) main функция: тут реализовать интерфейс для пользователя, убрать все в методы, тестить все остальные ветки
        // + комменты
        // + валидация
        // Алексей 2) CustomClass + builder (папка customClass)
        // Павел 3) Методы чтения входных данных + strategy pattern (папка readingInfo)
        // Виталий 4) Бинарный поиск (папка binarySearch)
        // Андрей 5) Сортировка  (папка sorting)
        // Так же каждый делает по файлу для теста своих методов в папке tests.
        Scanner inputScanner = new Scanner(System.in);

        UserInterface ui = new UserInterface();

        boolean runProgram = true;

        while (runProgram){
            ui.printCommands();//вывод пользовательского меню

            String commandNumber = inputScanner.nextLine();
            switch (commandNumber){
                //TODO все "кейсы" можно заменить на константы или enum, в целом как будто можно и так оставить
                //TODO функции чтения как будто по логике должны только возвращать массив Object, создание массива CustomClass
                // можно реализовать отдельно в том же CustomClass и передавать в метод массив Object. Какая-то валидация там уже не нужна
                // так как мы должны будем послать уже на этом этапе
                //все файлы для чтения входных данных пока лежат в папке readingInfo
                case "1"://Ввод данных
                    //TODO добавить метод в UserInput, которая возвращает массив Object для дальнейшей обработки (Object потому юзер будет вводить String, double, int)
                    //TODO Так же имеет смысл видимо в той же функции прописать логику с длиной массива (у меня в голове длина массива от юзера==количеству инпутов
                    // + мне кажется надо проверять чтобы по типам вышло все ровно, то есть мы ждем от юзера равное количество разных типов String/double/int
                    // и если не получаем от него, как пример, ровно три int три String и три double, то говорим что мы таким не занимаемся и идем на следующий виток)
                    // То есть в итоге метод должен уметь:
                    // 1) принимать длину массива
                    // 2) делать необходимое количество запросов на данные у юзера
                    // 3) валидировать что юзер не ввел гадостей/неверное количество ожидаемых данных
                    ui.chooseInputType();
                    String inputType = inputScanner.nextLine();
                    switch(inputType){
                        case "1"://Данные из файла

                            break;
                        case "2"://Данные из консоли

                            break;
                        case "3"://Случайные данные

                            break;
                        case "4"://Назад в меню

                            break;
                        default:
                            System.out.println("Введенная команда не поддерживается.");
                    }


                    break;
                case "2"://Получить отсортированные данные

                    break;

                case "3"://Поиск элемента


                    break;
                case "4":
                    runProgram = false;
                    break;
                default:
                    System.out.println("Введенная команда не поддерживается.");

            }


            //TODO тут прокидывать массив Object в наш CustomClass метод для преобразования в массив типа CustomClass[]

            //TODO после получения массива CustomClass[] отправлять его в функцию многопоточной сортировки (пока в процессе,
            // думаю что будет лежать в папке sorting). Так же можно решить делать сортировку всегда
            // или давать пользователю промт (типа "Посортируем?")
        }
    }




}



